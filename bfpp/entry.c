/* WARNING: This file was automatically generated by lua2c. */

#ifdef __cplusplus
extern "C" {
#endif
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"
#ifdef __cplusplus
}
#endif
#include <stdio.h>
#include <stdlib.h>


#include <string.h>


/* pushes new closure table onto the stack, using closure table at
 * given index as its parent */
static void lc_newclosuretable(lua_State * L, int idx) {

  lua_newtable(L);
  lua_pushvalue(L,idx);
  lua_rawseti(L,-2,0);


}

#include <assert.h>

/* function(ld, source, mode_, env) */
static int lcf6 (lua_State * L) {
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local f, err = loadstring(ld, source) */
  lua_getfield(L,LUA_ENVIRONINDEX,"loadstring");
  lua_pushvalue(L,1);
  lua_pushvalue(L,2);
  lua_call(L,2,2);
  assert(lua_gettop(L) == 6);
  
  /* if not f then */
  enum { lc3 = 6 };
  lua_pushboolean(L,!(lua_toboolean(L,5)));
  const int lc4 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc4) {
    
    /* return f, err */
    lua_pushvalue(L,5);
    lua_pushvalue(L,6);
    return 2;
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc3);
  assert(lua_gettop(L) == 6);
  
  /* return setfenv(f, env or _G) */
  const int lc5 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"setfenv");
  lua_pushvalue(L,5);
  lua_pushvalue(L,4);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"_G");
  }
  lua_call(L,2,LUA_MULTRET);
  return (lua_gettop(L) - lc5);
  assert(lua_gettop(L) == 6);
}


/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* name: countchar
 * function(s, c) */
static int lcf1_countchar (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local count = 0 */
  lua_pushnumber(L,0);
  assert(lua_gettop(L) == 3);
  
  /* local i = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 4);
  
  /* while true do */
  enum { lc8 = 4 };
  while (1) {
    lua_pushboolean(L,1);
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* i = string.find(s, c, i) */
    lua_getfield(L,LUA_ENVIRONINDEX,"string");
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,1);
    lua_pushvalue(L,2);
    lua_pushvalue(L,4);
    lua_call(L,3,1);
    lua_replace(L,4);
    assert(lua_gettop(L) == 4);
    
    /* if i then */
    enum { lc9 = 4 };
    if (lua_toboolean(L,4)) {
      
      /* count = count + 1 */
      lua_pushnumber(L,1);
      lc_add(L,3,-1);
      lua_remove(L,-2);
      lua_replace(L,3);
      assert(lua_gettop(L) == 4);
      
      /* i = i + 1 */
      lua_pushnumber(L,1);
      lc_add(L,4,-1);
      lua_remove(L,-2);
      lua_replace(L,4);
      assert(lua_gettop(L) == 4);
    }
    else {
      
      /* else
       * break */
      break;
      assert(lua_gettop(L) == 4);
    }
    lua_settop(L,lc9);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc8);
  assert(lua_gettop(L) == 4);
  
  /* return count */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 4);
}


/* gets upvalue with ID varid by consulting upvalue table at index
 * tidx for the upvalue table at given nesting level. */
static void lc_getupvalue(lua_State * L, int tidx, int level, int varid) {
  if (level == 0) {
    lua_rawgeti(L,tidx,varid);
  }
  else {
    lua_pushvalue(L,tidx);
    while (--level >= 0) {
      lua_rawgeti(L,tidx,0); /* 0 links to parent table */
      lua_remove(L,-2);
      tidx = -1;
    }
    lua_rawgeti(L,-1,varid);
    lua_remove(L,-2);
  }
}


/* __sub metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX < x < 0 are relative. */
static void lc_sub(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) && lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__sub")||luaL_getmetafield(L,idxb,"__sub")) {
      lua_pushvalue(L,idxa < 0 && idxa > LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb < 0 && idxb > LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}


/* function(a,n) */
static int lcf14 (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* n = tonumber(n) */
  lua_getfield(L,LUA_ENVIRONINDEX,"tonumber");
  lua_pushvalue(L,2);
  lua_call(L,1,1);
  lua_replace(L,2);
  assert(lua_gettop(L) == 2);
  
  /* local source_linenum =
   *       type(linenums) == "table" and (linenums[n] or '?') or
   *       type(linenums) == "number" and linenums + n - 1 or
   *       '?' */
  lua_getfield(L,LUA_ENVIRONINDEX,"type");
  lc_getupvalue(L,lua_upvalueindex(1),0,5);
  lua_call(L,1,1);
  lua_pushliteral(L,"table");
  const int lc12 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc12);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lc_getupvalue(L,lua_upvalueindex(1),0,5);
    lua_pushvalue(L,2);
    lua_gettable(L,-2);
    lua_remove(L,-2);
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"?");
    }
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"type");
    lc_getupvalue(L,lua_upvalueindex(1),0,5);
    lua_call(L,1,1);
    lua_pushliteral(L,"number");
    const int lc13 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc13);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lc_getupvalue(L,lua_upvalueindex(1),0,5);
      lc_add(L,-1,2);
      lua_remove(L,-2);
      lua_pushnumber(L,1);
      lc_sub(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
    }
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"?");
  }
  assert(lua_gettop(L) == 3);
  
  /* return a .. source_linenum */
  lua_pushvalue(L,1);
  lua_pushvalue(L,3);
  lua_concat(L,2);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: fix_linenums
 * function(message, linenums) */
static int lcf1_fix_linenums (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc11 = 3 };
  assert((lua_gettop(L) == lc11));
  lua_pushvalue(L,2);
  lua_rawseti(L,-2,5);
  
  /* message = message:gsub("(%b[]:)(%d+)", function(a,n)
   *     n = tonumber(n)
   *     local source_linenum =
   *       type(linenums) == "table" and (linenums[n] or '?') or
   *       type(linenums) == "number" and linenums + n - 1 or
   *       '?'
   *     return a .. source_linenum
   *   end) */
  lua_pushvalue(L,1);
  lua_pushliteral(L,"gsub");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"(%b[]:)(%d+)");
  lua_pushvalue(L,lc11);
  lua_pushcclosure(L,lcf14,1);
  lua_call(L,3,1);
  lua_replace(L,1);
  assert(lua_gettop(L) == 3);
  
  /* return message */
  lua_pushvalue(L,1);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: parse_dollar_paren
 * function(pieces, chunk, name, linenum) */
static int lcf1_parse_dollar_paren (lua_State * L) {
  lua_checkstack(L,27);
  enum { lc_nformalargs = 4 };
  lua_settop(L,4);
  
  /* local is = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 5);
  
  /* for ibegin, iend in chunk:gmatch("()$%b()()") do
   * internal: local f, s, var = explist */
  enum { lc16 = 5 };
  lua_pushvalue(L,2);
  lua_pushliteral(L,"gmatch");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushliteral(L,"()$%b()()");
  lua_call(L,2,3);
  while (1) {
    
    /* internal: local var_1, ..., var_n = f(s, var)
     *           if var_1 == nil then break end
     *           var = var_1 */
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_pushvalue(L,-3);
    lua_call(L,2,2);
    if (lua_isnil(L,-2)) {
      break;
    }
    lua_pushvalue(L,-2);
    lua_replace(L,-4);
    
    /* internal: local ibegin with idx 9
     * internal: local iend with idx 10 */
    
    
    /* local text = chunk:sub(is, ibegin - 1) */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"sub");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,5);
    lua_pushnumber(L,1);
    lc_sub(L,9,-1);
    lua_remove(L,-2);
    lua_call(L,3,1);
    assert(lua_gettop(L) == 11);
    
    /* local executed = chunk:sub(ibegin+2, iend-2) */
    lua_pushvalue(L,2);
    lua_pushliteral(L,"sub");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushnumber(L,2);
    lc_add(L,9,-1);
    lua_remove(L,-2);
    lua_pushnumber(L,2);
    lc_sub(L,10,-1);
    lua_remove(L,-2);
    lua_call(L,3,1);
    assert(lua_gettop(L) == 12);
    
    /* -- remove parens
     * local name2 = name .. ":" .. executed */
    lua_pushvalue(L,3);
    lua_pushliteral(L,":");
    lua_pushvalue(L,12);
    lua_concat(L,2);
    lua_concat(L,2);
    assert(lua_gettop(L) == 13);
    
    /* linenum = linenum + countchar(text, '\n') */
    lc_getupvalue(L,lua_upvalueindex(1),2,3);
    lua_pushvalue(L,11);
    lua_pushliteral(L,"\n");
    lua_call(L,2,1);
    lc_add(L,4,-1);
    lua_remove(L,-2);
    lua_replace(L,4);
    assert(lua_gettop(L) == 13);
    
    /* local may_have_comment = executed:find("%-%-") */
    lua_pushvalue(L,12);
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"%-%-");
    lua_call(L,2,1);
    assert(lua_gettop(L) == 14);
    
    /* local nl = may_have_comment and "\n" or "" */
    lua_pushvalue(L,14);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"\n");
    }
    if (!(lua_toboolean(L,-1))) {
      lua_pop(L,1);
      lua_pushliteral(L,"");
    }
    assert(lua_gettop(L) == 15);
    
    /* pieces[#pieces+1] = ("_put(%q)"):format(text) */
    lua_pushliteral(L,"_put(%q)");
    lua_pushliteral(L,"format");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,11);
    lua_call(L,2,1);
    const double lc17 = lua_objlen(L,1);
    lua_pushnumber(L,lc17);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,1);
    assert(lua_gettop(L) == 15);
    
    /* if load("return " .. executed, name2) then */
    enum { lc18 = 15 };
    lc_getupvalue(L,lua_upvalueindex(1),3,2);
    lua_pushliteral(L,"return ");
    lua_pushvalue(L,12);
    lua_concat(L,2);
    lua_pushvalue(L,13);
    lua_call(L,2,1);
    const int lc19 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc19) {
      
      /* -- is expression list
       * pieces[#pieces+1] = "_put(" .. executed .. nl .. ")" */
      lua_pushliteral(L,"_put(");
      lua_pushvalue(L,12);
      lua_pushvalue(L,15);
      lua_pushliteral(L,")");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      const double lc20 = lua_objlen(L,1);
      lua_pushnumber(L,lc20);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 15);
    }
    else {
      
      /* else
       * -- assume chunk
       * local status, message = load(executed, name2) */
      lc_getupvalue(L,lua_upvalueindex(1),3,2);
      lua_pushvalue(L,12);
      lua_pushvalue(L,13);
      lua_call(L,2,2);
      assert(lua_gettop(L) == 17);
      
      /* if not status then */
      enum { lc21 = 17 };
      lua_pushboolean(L,!(lua_toboolean(L,16)));
      const int lc22 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc22) {
        
        /* -- unrecognized
         * if message then */
        enum { lc23 = 17 };
        if (lua_toboolean(L,17)) {
          
          /* message = fix_linenums(message, linenum) */
          lc_getupvalue(L,lua_upvalueindex(1),1,4);
          lua_pushvalue(L,17);
          lua_pushvalue(L,4);
          lua_call(L,2,1);
          lua_replace(L,17);
          assert(lua_gettop(L) == 17);
        }
        lua_settop(L,lc23);
        assert(lua_gettop(L) == 17);
        
        /* return status, message */
        lua_pushvalue(L,16);
        lua_pushvalue(L,17);
        return 2;
        assert(lua_gettop(L) == 17);
      }
      lua_settop(L,lc21);
      assert(lua_gettop(L) == 17);
      
      /* pieces[#pieces+1] = " " .. executed .. nl .. " " */
      lua_pushliteral(L," ");
      lua_pushvalue(L,12);
      lua_pushvalue(L,15);
      lua_pushliteral(L," ");
      lua_concat(L,2);
      lua_concat(L,2);
      lua_concat(L,2);
      const double lc24 = lua_objlen(L,1);
      lua_pushnumber(L,lc24);
      lua_pushnumber(L,1);
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      lua_insert(L,-2);
      lua_settable(L,1);
      assert(lua_gettop(L) == 17);
      
      /* linenum = linenum + countchar(executed, '\n') */
      lc_getupvalue(L,lua_upvalueindex(1),2,3);
      lua_pushvalue(L,12);
      lua_pushliteral(L,"\n");
      lua_call(L,2,1);
      lc_add(L,4,-1);
      lua_remove(L,-2);
      lua_replace(L,4);
      assert(lua_gettop(L) == 17);
    }
    lua_settop(L,lc18);
    assert(lua_gettop(L) == 15);
    
    /* is = iend */
    lua_pushvalue(L,10);
    lua_replace(L,5);
    assert(lua_gettop(L) == 15);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,7);
  }
  lua_settop(L,lc16);
  assert(lua_gettop(L) == 5);
  
  /* pieces[#pieces+1] = ("_put(%q)"):format(chunk:sub(is)) */
  lua_pushliteral(L,"_put(%q)");
  const int lc25 = lua_gettop(L);
  lua_pushliteral(L,"format");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,2);
  lua_pushliteral(L,"sub");
  lua_gettable(L,-2);
  lua_insert(L,-2);
  lua_pushvalue(L,5);
  lua_call(L,2,LUA_MULTRET);
  lua_call(L,(lua_gettop(L) - lc25),1);
  const double lc26 = lua_objlen(L,1);
  lua_pushnumber(L,lc26);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_settable(L,1);
  assert(lua_gettop(L) == 5);
  
  /* return true */
  lua_pushboolean(L,1);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* name: parse_hash_lines
 * function(chunk, name, env) */
static int lcf1_parse_hash_lines (lua_State * L) {
  lua_checkstack(L,25);
  enum { lc_nformalargs = 3 };
  lua_settop(L,3);
  
  /* local pieces = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 4);
  
  /* local luas = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 5);
  
  /* -- for improved error reporting
   * local linenums = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 6);
  
  /* local linenum = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 7);
  
  /* pieces[#pieces+1] = "local _put = ... " */
  lua_pushliteral(L,"local _put = ... ");
  const double lc28 = lua_objlen(L,4);
  lua_pushnumber(L,lc28);
  lua_pushnumber(L,1);
  lc_add(L,-2,-1);
  lua_remove(L,-2);
  lua_remove(L,-2);
  lua_insert(L,-2);
  lua_settable(L,4);
  assert(lua_gettop(L) == 7);
  
  /* local is = 1 */
  lua_pushnumber(L,1);
  assert(lua_gettop(L) == 8);
  
  /* while true do */
  enum { lc29 = 8 };
  while (1) {
    lua_pushboolean(L,1);
    if (!(lua_toboolean(L,-1))) {
      break;
    }
    lua_pop(L,1);
    
    /* local _, ie, lua = chunk:find("^#+([^\n]*\n?)", is) */
    lua_pushvalue(L,1);
    lua_pushliteral(L,"find");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushliteral(L,"^#+([^\n]*\n?)");
    lua_pushvalue(L,8);
    lua_call(L,3,3);
    assert(lua_gettop(L) == 11);
    
    /* if not ie then */
    enum { lc30 = 11 };
    lua_pushboolean(L,!(lua_toboolean(L,10)));
    const int lc31 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc31) {
      
      /* local iss */
      lua_settop(L,(lua_gettop(L) + 1));
      assert(lua_gettop(L) == 12);
      
      /* iss, ie, lua = chunk:find("\n#+([^\n]*\n?)", is) */
      lua_pushvalue(L,1);
      lua_pushliteral(L,"find");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"\n#+([^\n]*\n?)");
      lua_pushvalue(L,8);
      lua_call(L,3,3);
      lua_replace(L,11);
      lua_replace(L,10);
      lua_replace(L,12);
      assert(lua_gettop(L) == 12);
      
      /* local text = chunk:sub(is, iss) */
      lua_pushvalue(L,1);
      lua_pushliteral(L,"sub");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushvalue(L,8);
      lua_pushvalue(L,12);
      lua_call(L,3,1);
      assert(lua_gettop(L) == 13);
      
      /* local status, message = parse_dollar_paren(pieces, text, name, linenum) */
      lc_getupvalue(L,lua_upvalueindex(1),1,6);
      lua_pushvalue(L,4);
      lua_pushvalue(L,13);
      lua_pushvalue(L,2);
      lua_pushvalue(L,7);
      lua_call(L,4,2);
      assert(lua_gettop(L) == 15);
      
      /* if not status then */
      enum { lc32 = 15 };
      lua_pushboolean(L,!(lua_toboolean(L,14)));
      const int lc33 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc33) {
        
        /* return status, message */
        lua_pushvalue(L,14);
        lua_pushvalue(L,15);
        return 2;
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc32);
      assert(lua_gettop(L) == 15);
      
      /* if not ie then */
      enum { lc34 = 15 };
      lua_pushboolean(L,!(lua_toboolean(L,10)));
      const int lc35 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc35) {
        
        /* break */
        break;
        assert(lua_gettop(L) == 15);
      }
      lua_settop(L,lc34);
      assert(lua_gettop(L) == 15);
      
      /* linenum = linenum + countchar(text, '\n') */
      lc_getupvalue(L,lua_upvalueindex(1),3,3);
      lua_pushvalue(L,13);
      lua_pushliteral(L,"\n");
      lua_call(L,2,1);
      lc_add(L,7,-1);
      lua_remove(L,-2);
      lua_replace(L,7);
      assert(lua_gettop(L) == 15);
    }
    lua_settop(L,lc30);
    assert(lua_gettop(L) == 11);
    
    /* luas[#luas+1] = lua */
    lua_pushvalue(L,11);
    const double lc36 = lua_objlen(L,5);
    lua_pushnumber(L,lc36);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,5);
    assert(lua_gettop(L) == 11);
    
    /* linenums[#linenums+1] = linenum */
    lua_pushvalue(L,7);
    const double lc37 = lua_objlen(L,6);
    lua_pushnumber(L,lc37);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,6);
    assert(lua_gettop(L) == 11);
    
    /* linenum = linenum + 1 */
    lua_pushnumber(L,1);
    lc_add(L,7,-1);
    lua_remove(L,-2);
    lua_replace(L,7);
    assert(lua_gettop(L) == 11);
    
    /* pieces[#pieces+1] = ' ' .. lua .. ' ' */
    lua_pushliteral(L," ");
    lua_pushvalue(L,11);
    lua_pushliteral(L," ");
    lua_concat(L,2);
    lua_concat(L,2);
    const double lc38 = lua_objlen(L,4);
    lua_pushnumber(L,lc38);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,4);
    assert(lua_gettop(L) == 11);
    
    /* is = ie + 1 */
    lua_pushnumber(L,1);
    lc_add(L,10,-1);
    lua_remove(L,-2);
    lua_replace(L,8);
    assert(lua_gettop(L) == 11);
    
    /* internal: stack cleanup on scope exit */
    lua_pop(L,3);
  }
  lua_settop(L,lc29);
  assert(lua_gettop(L) == 8);
  
  /* local code = table.concat(pieces, ' ') */
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"concat");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_pushvalue(L,4);
  lua_pushliteral(L," ");
  lua_call(L,2,1);
  assert(lua_gettop(L) == 9);
  
  /* -- Attempt to compile.
   * local f, message = load(code, name, 't', env) */
  lc_getupvalue(L,lua_upvalueindex(1),4,2);
  lua_pushvalue(L,9);
  lua_pushvalue(L,2);
  lua_pushliteral(L,"t");
  lua_pushvalue(L,3);
  lua_call(L,4,2);
  assert(lua_gettop(L) == 11);
  
  /* if not f then */
  enum { lc39 = 11 };
  lua_pushboolean(L,!(lua_toboolean(L,10)));
  const int lc40 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc40) {
    
    /* -- Attempt to compile only user-written Lua
     * -- (for cleaner error message)
     * local lua = table.concat(luas) */
    lua_getfield(L,LUA_ENVIRONINDEX,"table");
    lua_pushliteral(L,"concat");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushvalue(L,5);
    lua_call(L,1,1);
    assert(lua_gettop(L) == 12);
    
    /* local f2, message2 = load(lua, name, 't', env) */
    lc_getupvalue(L,lua_upvalueindex(1),4,2);
    lua_pushvalue(L,12);
    lua_pushvalue(L,2);
    lua_pushliteral(L,"t");
    lua_pushvalue(L,3);
    lua_call(L,4,2);
    assert(lua_gettop(L) == 14);
    
    /* if not f2 then */
    enum { lc41 = 14 };
    lua_pushboolean(L,!(lua_toboolean(L,13)));
    const int lc42 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc42) {
      
      /* message = fix_linenums(message2, linenums) */
      lc_getupvalue(L,lua_upvalueindex(1),2,4);
      lua_pushvalue(L,14);
      lua_pushvalue(L,6);
      lua_call(L,2,1);
      lua_replace(L,11);
      assert(lua_gettop(L) == 14);
    }
    else {
      
      /* else
       * -- unexpected
       * message = fix_linenums(message, nil) */
      lc_getupvalue(L,lua_upvalueindex(1),2,4);
      lua_pushvalue(L,11);
      lua_pushnil(L);
      lua_call(L,2,1);
      lua_replace(L,11);
      assert(lua_gettop(L) == 14);
    }
    lua_settop(L,lc41);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc39);
  assert(lua_gettop(L) == 11);
  
  /* return f, message */
  lua_pushvalue(L,10);
  lua_pushvalue(L,11);
  return 2;
  assert(lua_gettop(L) == 11);
}


/* name: write
 * function(...) */
static int lcf1_write (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local n = select('#', ...) */
  lua_getfield(L,LUA_ENVIRONINDEX,"select");
  const int lc46 = lua_gettop(L);
  lua_pushliteral(L,"#");
  {int i; for (i=lc_nformalargs+1; i<=lc_nactualargs; i++) { lua_pushvalue(L, i); }}
  lua_call(L,(lua_gettop(L) - lc46),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* if n > 0 then */
  enum { lc47 = 1 };
  lua_pushnumber(L,0);
  const int lc48 = lua_lessthan(L,-1,(1 + lc_nextra));
  lua_pop(L,1);
  lua_pushboolean(L,lc48);
  const int lc49 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc49) {
    
    /* t[#t+1] = tostring((...)) */
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushvalue(L,(lc_nformalargs + 1));
    lua_call(L,1,1);
    lc_getupvalue(L,lua_upvalueindex(1),1,9);
    lua_insert(L,-2);
    lc_getupvalue(L,lua_upvalueindex(1),1,9);
    const double lc50 = lua_objlen(L,-1);
    lua_pop(L,1);
    lua_pushnumber(L,lc50);
    lua_pushnumber(L,1);
    lc_add(L,-2,-1);
    lua_remove(L,-2);
    lua_remove(L,-2);
    lua_insert(L,-2);
    lua_settable(L,-3);
    lua_pop(L,1);
    assert(lua_gettop(L) - lc_nextra == 1);
    
    /* write(select(2, ...)) */
    lc_getupvalue(L,lua_upvalueindex(1),0,10);
    const int lc51 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"select");
    const int lc52 = lua_gettop(L);
    lua_pushnumber(L,2);
    {int i; for (i=lc_nformalargs+1; i<=lc_nactualargs; i++) { lua_pushvalue(L, i); }}
    lua_call(L,(lua_gettop(L) - lc52),LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc51),0);
    assert(lua_gettop(L) - lc_nextra == 1);
  }
  lua_settop(L,(lc47 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 1);
  return 0;
}


/* name: close
 * function() */
static int lcf1_close (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* return table.concat(t) */
  const int lc53 = lua_gettop(L);
  lua_getfield(L,LUA_ENVIRONINDEX,"table");
  lua_pushliteral(L,"concat");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lc_getupvalue(L,lua_upvalueindex(1),1,9);
  lua_call(L,1,LUA_MULTRET);
  return (lua_gettop(L) - lc53);
  assert(lua_gettop(L) == 0);
}


/* name: string_writer
 * function() */
static int lcf1_string_writer (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* local t = {} */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc44 = 1 };
  assert((lua_gettop(L) == lc44));
  lua_newtable(L);
  lua_rawseti(L,lc44,9);
  assert(lua_gettop(L) == 1);
  
  /* local function write(...)
   *     local n = select('#', ...)
   *     if n > 0 then
   *       t[#t+1] = tostring((...))
   *       write(select(2, ...))
   *     end
   *   end */
  lc_newclosuretable(L,lc44);
  enum { lc45 = 2 };
  assert((lua_gettop(L) == lc45));
  lua_pushvalue(L,lc45);
  lua_pushcclosure(L,lcf1_write,1);
  lua_rawseti(L,lc45,10);
  assert(lua_gettop(L) == 2);
  
  /* local function close()
   *     return table.concat(t)
   *   end */
  lua_pushvalue(L,lc45);
  lua_pushcclosure(L,lcf1_close,1);
  assert(lua_gettop(L) == 3);
  
  /* return {write=write, close=close} */
  lua_createtable(L,0,2);
  lua_pushliteral(L,"write");
  lc_getupvalue(L,lc45,0,10);
  lua_rawset(L,-3);
  lua_pushliteral(L,"close");
  lua_pushvalue(L,3);
  lua_rawset(L,-3);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: write
 * function(...) */
static int lcf2_write (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local n = select('#', ...) */
  lua_getfield(L,LUA_ENVIRONINDEX,"select");
  const int lc57 = lua_gettop(L);
  lua_pushliteral(L,"#");
  {int i; for (i=lc_nformalargs+1; i<=lc_nactualargs; i++) { lua_pushvalue(L, i); }}
  lua_call(L,(lua_gettop(L) - lc57),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* if n > 0 then */
  enum { lc58 = 1 };
  lua_pushnumber(L,0);
  const int lc59 = lua_lessthan(L,-1,(1 + lc_nextra));
  lua_pop(L,1);
  lua_pushboolean(L,lc59);
  const int lc60 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc60) {
    
    /* fh:write(tostring((...))) */
    lc_getupvalue(L,lua_upvalueindex(1),1,12);
    const int lc61 = lua_gettop(L);
    lua_pushliteral(L,"write");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushvalue(L,(lc_nformalargs + 1));
    lua_call(L,1,LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc61),0);
    assert(lua_gettop(L) - lc_nextra == 1);
    
    /* write(select(2, ...)) */
    lc_getupvalue(L,lua_upvalueindex(1),0,14);
    const int lc62 = lua_gettop(L);
    lua_getfield(L,LUA_ENVIRONINDEX,"select");
    const int lc63 = lua_gettop(L);
    lua_pushnumber(L,2);
    {int i; for (i=lc_nformalargs+1; i<=lc_nactualargs; i++) { lua_pushvalue(L, i); }}
    lua_call(L,(lua_gettop(L) - lc63),LUA_MULTRET);
    lua_call(L,(lua_gettop(L) - lc62),0);
    assert(lua_gettop(L) - lc_nextra == 1);
  }
  lua_settop(L,(lc58 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 1);
  return 0;
}


/* name: close
 * function() */
static int lcf2_close (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* if is_close then */
  enum { lc64 = 0 };
  lc_getupvalue(L,lua_upvalueindex(1),1,13);
  const int lc65 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc65) {
    
    /* fh:close() */
    lc_getupvalue(L,lua_upvalueindex(1),1,12);
    lua_pushliteral(L,"close");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 0);
  }
  lua_settop(L,lc64);
  assert(lua_gettop(L) == 0);
  return 0;
}


/* name: file_writer
 * function(fh, is_close) */
static int lcf1_file_writer (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc55 = 3 };
  assert((lua_gettop(L) == lc55));
  lua_pushvalue(L,1);
  lua_rawseti(L,-2,12);
  lua_pushvalue(L,2);
  lua_rawseti(L,-2,13);
  
  /* local function write(...)
   *     local n = select('#', ...)
   *     if n > 0 then
   *       fh:write(tostring((...)))
   *       write(select(2, ...))
   *     end
   *   end */
  lc_newclosuretable(L,lc55);
  enum { lc56 = 4 };
  assert((lua_gettop(L) == lc56));
  lua_pushvalue(L,lc56);
  lua_pushcclosure(L,lcf2_write,1);
  lua_rawseti(L,lc56,14);
  assert(lua_gettop(L) == 4);
  
  /* local function close()
   *     if is_close then fh:close() end
   *   end */
  lua_pushvalue(L,lc56);
  lua_pushcclosure(L,lcf2_close,1);
  assert(lua_gettop(L) == 5);
  
  /* return {write=write, close=close} */
  lua_createtable(L,0,2);
  lua_pushliteral(L,"write");
  lc_getupvalue(L,lc56,0,14);
  lua_rawset(L,-3);
  lua_pushliteral(L,"close");
  lua_pushvalue(L,5);
  lua_rawset(L,-3);
  return 1;
  assert(lua_gettop(L) == 5);
}


/* name: make_output
 * function(output) */
static int lcf1_make_output (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if type(output) == 'string' then */
  enum { lc67 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"type");
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"string");
  const int lc68 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc68);
  const int lc69 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc69) {
    
    /* output = string_writer() */
    lc_getupvalue(L,lua_upvalueindex(1),2,8);
    lua_call(L,0,1);
    lua_replace(L,1);
    assert(lua_gettop(L) == 1);
  }
  else {
    
    /* elseif type(output) == 'table' then */
    enum { lc70 = 1 };
    lua_getfield(L,LUA_ENVIRONINDEX,"type");
    lua_pushvalue(L,1);
    lua_call(L,1,1);
    lua_pushliteral(L,"table");
    const int lc71 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc71);
    const int lc72 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc72) {
      
      /* assert(#output == 1, 'table size must be 1') */
      lua_getfield(L,LUA_ENVIRONINDEX,"assert");
      const double lc73 = lua_objlen(L,1);
      lua_pushnumber(L,lc73);
      lua_pushnumber(L,1);
      const int lc74 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc74);
      lua_pushliteral(L,"table size must be 1");
      lua_call(L,2,0);
      assert(lua_gettop(L) == 1);
      
      /* local filename = output[1] */
      lua_pushnumber(L,1);
      lua_gettable(L,1);
      assert(lua_gettop(L) == 2);
      
      /* local fh, message = io.open(filename, 'w') */
      lua_getfield(L,LUA_ENVIRONINDEX,"io");
      lua_pushliteral(L,"open");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_pushliteral(L,"w");
      lua_call(L,2,2);
      assert(lua_gettop(L) == 4);
      
      /* if not fh then */
      enum { lc75 = 4 };
      lua_pushboolean(L,!(lua_toboolean(L,3)));
      const int lc76 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc76) {
        
        /* return false, message */
        lua_pushboolean(L,0);
        lua_pushvalue(L,4);
        return 2;
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L,lc75);
      assert(lua_gettop(L) == 4);
      
      /* output = file_writer(fh, true) */
      lc_getupvalue(L,lua_upvalueindex(1),1,11);
      lua_pushvalue(L,3);
      lua_pushboolean(L,1);
      lua_call(L,2,1);
      lua_replace(L,1);
      assert(lua_gettop(L) == 4);
    }
    else {
      
      /* elseif io.type(output) == 'file' then */
      enum { lc77 = 1 };
      lua_getfield(L,LUA_ENVIRONINDEX,"io");
      lua_pushliteral(L,"type");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_call(L,1,1);
      lua_pushliteral(L,"file");
      const int lc78 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc78);
      const int lc79 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc79) {
        
        /* output = file_writer(output, false) */
        lc_getupvalue(L,lua_upvalueindex(1),1,11);
        lua_pushvalue(L,1);
        lua_pushboolean(L,0);
        lua_call(L,2,1);
        lua_replace(L,1);
        assert(lua_gettop(L) == 1);
      }
      else {
        
        /* else
         * error('unrecognized', 2) */
        lua_getfield(L,LUA_ENVIRONINDEX,"error");
        lua_pushliteral(L,"unrecognized");
        lua_pushnumber(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 1);
      }
      lua_settop(L,lc77);
    }
    lua_settop(L,lc70);
  }
  lua_settop(L,lc67);
  assert(lua_gettop(L) == 1);
  
  /* return output */
  lua_pushvalue(L,1);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* name: make_input
 * function(input) */
static int lcf1_make_input (lua_State * L) {
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if type(input) == 'string' then */
  enum { lc81 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"type");
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"string");
  const int lc82 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc82);
  const int lc83 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc83) {
    
    /* input = {text = input, name = 'source'} */
    lua_createtable(L,0,2);
    lua_pushliteral(L,"text");
    lua_pushvalue(L,1);
    lua_rawset(L,-3);
    lua_pushliteral(L,"name");
    lua_pushliteral(L,"source");
    lua_rawset(L,-3);
    lua_replace(L,1);
    assert(lua_gettop(L) == 1);
  }
  else {
    
    /* elseif type(input) == 'table' then */
    enum { lc84 = 1 };
    lua_getfield(L,LUA_ENVIRONINDEX,"type");
    lua_pushvalue(L,1);
    lua_call(L,1,1);
    lua_pushliteral(L,"table");
    const int lc85 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc85);
    const int lc86 = lua_toboolean(L,-1);
    lua_pop(L,1);
    if (lc86) {
      
      /* assert(#input == 1, 'table size must be 1') */
      lua_getfield(L,LUA_ENVIRONINDEX,"assert");
      const double lc87 = lua_objlen(L,1);
      lua_pushnumber(L,lc87);
      lua_pushnumber(L,1);
      const int lc88 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc88);
      lua_pushliteral(L,"table size must be 1");
      lua_call(L,2,0);
      assert(lua_gettop(L) == 1);
      
      /* local filename = input[1] */
      lua_pushnumber(L,1);
      lua_gettable(L,1);
      assert(lua_gettop(L) == 2);
      
      /* local fh, message = io.open(filename) */
      lua_getfield(L,LUA_ENVIRONINDEX,"io");
      lua_pushliteral(L,"open");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,2);
      lua_call(L,1,2);
      assert(lua_gettop(L) == 4);
      
      /* if not fh then */
      enum { lc89 = 4 };
      lua_pushboolean(L,!(lua_toboolean(L,3)));
      const int lc90 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc90) {
        
        /* return false, message */
        lua_pushboolean(L,0);
        lua_pushvalue(L,4);
        return 2;
        assert(lua_gettop(L) == 4);
      }
      lua_settop(L,lc89);
      assert(lua_gettop(L) == 4);
      
      /* input = {text = fh:read'*a', name = filename} */
      lua_createtable(L,0,2);
      lua_pushliteral(L,"text");
      lua_pushvalue(L,3);
      lua_pushliteral(L,"read");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_pushliteral(L,"*a");
      lua_call(L,2,1);
      lua_rawset(L,-3);
      lua_pushliteral(L,"name");
      lua_pushvalue(L,2);
      lua_rawset(L,-3);
      lua_replace(L,1);
      assert(lua_gettop(L) == 4);
      
      /* fh:close() */
      lua_pushvalue(L,3);
      lua_pushliteral(L,"close");
      lua_gettable(L,-2);
      lua_insert(L,-2);
      lua_call(L,1,0);
      assert(lua_gettop(L) == 4);
    }
    else {
      
      /* elseif io.type(input) == 'file' then */
      enum { lc91 = 1 };
      lua_getfield(L,LUA_ENVIRONINDEX,"io");
      lua_pushliteral(L,"type");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,1);
      lua_call(L,1,1);
      lua_pushliteral(L,"file");
      const int lc92 = lua_equal(L,-2,-1);
      lua_pop(L,2);
      lua_pushboolean(L,lc92);
      const int lc93 = lua_toboolean(L,-1);
      lua_pop(L,1);
      if (lc93) {
        
        /* input = {text = input:read'*a', name = nil} */
        lua_createtable(L,0,2);
        lua_pushliteral(L,"text");
        lua_pushvalue(L,1);
        lua_pushliteral(L,"read");
        lua_gettable(L,-2);
        lua_insert(L,-2);
        lua_pushliteral(L,"*a");
        lua_call(L,2,1);
        lua_rawset(L,-3);
        lua_pushliteral(L,"name");
        lua_pushnil(L);
        lua_rawset(L,-3);
        lua_replace(L,1);
        assert(lua_gettop(L) == 1);
      }
      else {
        
        /* else
         * error('unrecognized', 2) */
        lua_getfield(L,LUA_ENVIRONINDEX,"error");
        lua_pushliteral(L,"unrecognized");
        lua_pushnumber(L,2);
        lua_call(L,2,0);
        assert(lua_gettop(L) == 1);
      }
      lua_settop(L,lc91);
    }
    lua_settop(L,lc84);
  }
  lua_settop(L,lc81);
  assert(lua_gettop(L) == 1);
  
  /* return input */
  lua_pushvalue(L,1);
  return 1;
  assert(lua_gettop(L) == 1);
}


/* name: mt.__index
 * function(t,k) */
static int lcf1_mt___index (lua_State * L) {
  enum { lc_nformalargs = 2 };
  lua_settop(L,2);
  
  /* local v = lookup[k] */
  lc_getupvalue(L,lua_upvalueindex(1),0,17);
  lua_pushvalue(L,2);
  lua_gettable(L,-2);
  lua_remove(L,-2);
  assert(lua_gettop(L) == 3);
  
  /* if v == nil then */
  enum { lc105 = 3 };
  lua_pushnil(L);
  const int lc106 = lua_equal(L,3,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc106);
  const int lc107 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc107) {
    
    /* error("Undefined global variable " .. tostring(k), 2) */
    lua_getfield(L,LUA_ENVIRONINDEX,"error");
    lua_pushliteral(L,"Undefined global variable ");
    lua_getfield(L,LUA_ENVIRONINDEX,"tostring");
    lua_pushvalue(L,2);
    lua_call(L,1,1);
    lua_concat(L,2);
    lua_pushnumber(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 3);
  }
  lua_settop(L,lc105);
  assert(lua_gettop(L) == 3);
  
  /* return v */
  lua_pushvalue(L,3);
  return 1;
  assert(lua_gettop(L) == 3);
}


/* name: M.preprocess
 * function(t) */
static int lcf1_M_preprocess (lua_State * L) {
  lua_checkstack(L,24);
  enum { lc_nformalargs = 1 };
  lua_settop(L,1);
  
  /* if type(t) == 'string' then */
  enum { lc94 = 1 };
  lua_getfield(L,LUA_ENVIRONINDEX,"type");
  lua_pushvalue(L,1);
  lua_call(L,1,1);
  lua_pushliteral(L,"string");
  const int lc95 = lua_equal(L,-2,-1);
  lua_pop(L,2);
  lua_pushboolean(L,lc95);
  const int lc96 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc96) {
    
    /* t = {input = t} */
    lua_createtable(L,0,1);
    lua_pushliteral(L,"input");
    lua_pushvalue(L,1);
    lua_rawset(L,-3);
    lua_replace(L,1);
    assert(lua_gettop(L) == 1);
  }
  lua_settop(L,lc94);
  assert(lua_gettop(L) == 1);
  
  /* local input = t.input or io.stdin */
  lua_pushliteral(L,"input");
  lua_gettable(L,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"io");
    lua_pushliteral(L,"stdin");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  assert(lua_gettop(L) == 2);
  
  /* local output = t.output or
   *              (type(input) == 'string' and 'string') or io.stdout */
  lua_pushliteral(L,"output");
  lua_gettable(L,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"type");
    lua_pushvalue(L,2);
    lua_call(L,1,1);
    lua_pushliteral(L,"string");
    const int lc97 = lua_equal(L,-2,-1);
    lua_pop(L,2);
    lua_pushboolean(L,lc97);
    if (lua_toboolean(L,-1)) {
      lua_pop(L,1);
      lua_pushliteral(L,"string");
    }
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"io");
    lua_pushliteral(L,"stdout");
    lua_gettable(L,-2);
    lua_remove(L,-2);
  }
  assert(lua_gettop(L) == 3);
  
  /* local lookup = t.lookup or _G */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc98 = 4 };
  assert((lua_gettop(L) == lc98));
  lua_pushliteral(L,"lookup");
  lua_gettable(L,1);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"_G");
  }
  lua_rawseti(L,lc98,17);
  assert(lua_gettop(L) == 4);
  
  /* local strict = t.strict */
  lua_pushliteral(L,"strict");
  lua_gettable(L,1);
  assert(lua_gettop(L) == 5);
  
  /* if strict == nil then */
  enum { lc99 = 5 };
  lua_pushnil(L);
  const int lc100 = lua_equal(L,5,-1);
  lua_pop(L,1);
  lua_pushboolean(L,lc100);
  const int lc101 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc101) {
    
    /* strict = true */
    lua_pushboolean(L,1);
    lua_replace(L,5);
    assert(lua_gettop(L) == 5);
  }
  lua_settop(L,lc99);
  assert(lua_gettop(L) == 5);
  
  /* local err */
  lua_settop(L,(lua_gettop(L) + 1));
  assert(lua_gettop(L) == 6);
  
  /* input, err = make_input(input) */
  lc_getupvalue(L,lc98,1,16);
  lua_pushvalue(L,2);
  lua_call(L,1,2);
  lua_replace(L,6);
  lua_replace(L,2);
  assert(lua_gettop(L) == 6);
  
  /* if not input then */
  enum { lc102 = 6 };
  lua_pushboolean(L,!(lua_toboolean(L,2)));
  const int lc103 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc103) {
    
    /* error(err, 2) */
    lua_getfield(L,LUA_ENVIRONINDEX,"error");
    lua_pushvalue(L,6);
    lua_pushnumber(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 6);
  }
  lua_settop(L,lc102);
  assert(lua_gettop(L) == 6);
  
  /* local name = input.name or "<source>" */
  lua_pushliteral(L,"name");
  lua_gettable(L,2);
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushliteral(L,"<source>");
  }
  assert(lua_gettop(L) == 7);
  
  /* local mt = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 8);
  
  /* if strict then */
  enum { lc104 = 8 };
  if (lua_toboolean(L,5)) {
    
    /* function mt.__index(t,k)
     *       local v = lookup[k]
     *       if v == nil then
     *         error("Undefined global variable " .. tostring(k), 2)
     *       end
     *       return v
     *     end */
    lua_pushvalue(L,lc98);
    lua_pushcclosure(L,lcf1_mt___index,1);
    lua_pushliteral(L,"__index");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 8);
  }
  else {
    
    /* else
     * mt.__index = lookup */
    lc_getupvalue(L,lc98,0,17);
    lua_pushliteral(L,"__index");
    lua_insert(L,-2);
    lua_settable(L,8);
    assert(lua_gettop(L) == 8);
  }
  lua_settop(L,lc104);
  assert(lua_gettop(L) == 8);
  
  /* local env = {} */
  lua_newtable(L);
  assert(lua_gettop(L) == 9);
  
  /* setmetatable(env, mt) */
  lua_getfield(L,LUA_ENVIRONINDEX,"setmetatable");
  lua_pushvalue(L,9);
  lua_pushvalue(L,8);
  lua_call(L,2,0);
  assert(lua_gettop(L) == 9);
  
  /* local f, message = parse_hash_lines(input.text, name, env) */
  lc_getupvalue(L,lc98,5,7);
  lua_pushliteral(L,"text");
  lua_gettable(L,2);
  lua_pushvalue(L,7);
  lua_pushvalue(L,9);
  lua_call(L,3,2);
  assert(lua_gettop(L) == 11);
  
  /* if not f then */
  enum { lc108 = 11 };
  lua_pushboolean(L,!(lua_toboolean(L,10)));
  const int lc109 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc109) {
    
    /* return f, message */
    lua_pushvalue(L,10);
    lua_pushvalue(L,11);
    return 2;
    assert(lua_gettop(L) == 11);
  }
  lua_settop(L,lc108);
  assert(lua_gettop(L) == 11);
  
  /* output = make_output(output) */
  lc_getupvalue(L,lc98,2,15);
  lua_pushvalue(L,3);
  lua_call(L,1,1);
  lua_replace(L,3);
  assert(lua_gettop(L) == 11);
  
  /* local status, message = pcall(f, output.write) */
  lua_getfield(L,LUA_ENVIRONINDEX,"pcall");
  lua_pushvalue(L,10);
  lua_pushliteral(L,"write");
  lua_gettable(L,3);
  lua_call(L,2,2);
  assert(lua_gettop(L) == 13);
  
  /* local result = output.close() */
  lua_pushliteral(L,"close");
  lua_gettable(L,3);
  lua_call(L,0,1);
  assert(lua_gettop(L) == 14);
  
  /* if not result then */
  enum { lc110 = 14 };
  lua_pushboolean(L,!(lua_toboolean(L,14)));
  const int lc111 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc111) {
    
    /* result = true */
    lua_pushboolean(L,1);
    lua_replace(L,14);
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc110);
  assert(lua_gettop(L) == 14);
  
  /* if not status then */
  enum { lc112 = 14 };
  lua_pushboolean(L,!(lua_toboolean(L,12)));
  const int lc113 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc113) {
    
    /* return false, message */
    lua_pushboolean(L,0);
    lua_pushvalue(L,13);
    return 2;
    assert(lua_gettop(L) == 14);
  }
  else {
    
    /* else
     * return result */
    lua_pushvalue(L,14);
    return 1;
    assert(lua_gettop(L) == 14);
  }
  lua_settop(L,lc112);
  assert(lua_gettop(L) == 14);
  return 0;
}


/* name: command
 * function() */
static int lcf1_command (lua_State * L) {
  enum { lc_nformalargs = 0 };
  lua_settop(L,0);
  
  /* input = io.stdin */
  lua_getfield(L,LUA_ENVIRONINDEX,"io");
  lua_pushliteral(L,"stdin");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_setfield(L,LUA_ENVIRONINDEX,"input");
  assert(lua_gettop(L) == 0);
  
  /* output = io.stdout */
  lua_getfield(L,LUA_ENVIRONINDEX,"io");
  lua_pushliteral(L,"stdout");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_setfield(L,LUA_ENVIRONINDEX,"output");
  assert(lua_gettop(L) == 0);
  
  /* local input, output */
  lua_settop(L,(lua_gettop(L) + 2));
  assert(lua_gettop(L) == 2);
  
  /* local status, message = M.preprocess{input=input, output=output, lookup=_G} */
  lc_getupvalue(L,lua_upvalueindex(1),9,1);
  lua_pushliteral(L,"preprocess");
  lua_gettable(L,-2);
  lua_remove(L,-2);
  lua_createtable(L,0,3);
  lua_pushliteral(L,"input");
  lua_pushvalue(L,1);
  lua_rawset(L,-3);
  lua_pushliteral(L,"output");
  lua_pushvalue(L,2);
  lua_rawset(L,-3);
  lua_pushliteral(L,"lookup");
  lua_getfield(L,LUA_ENVIRONINDEX,"_G");
  lua_rawset(L,-3);
  lua_call(L,1,2);
  assert(lua_gettop(L) == 4);
  
  /* if not status then */
  enum { lc114 = 4 };
  lua_pushboolean(L,!(lua_toboolean(L,3)));
  const int lc115 = lua_toboolean(L,-1);
  lua_pop(L,1);
  if (lc115) {
    
    /* io.stderr:write(message .. "\n") */
    lua_getfield(L,LUA_ENVIRONINDEX,"io");
    lua_pushliteral(L,"stderr");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushliteral(L,"write");
    lua_gettable(L,-2);
    lua_insert(L,-2);
    lua_pushvalue(L,4);
    lua_pushliteral(L,"\n");
    lua_concat(L,2);
    lua_call(L,2,0);
    assert(lua_gettop(L) == 4);
    
    /* os.exit(1) */
    lua_getfield(L,LUA_ENVIRONINDEX,"os");
    lua_pushliteral(L,"exit");
    lua_gettable(L,-2);
    lua_remove(L,-2);
    lua_pushnumber(L,1);
    lua_call(L,1,0);
    assert(lua_gettop(L) == 4);
  }
  lua_settop(L,lc114);
  assert(lua_gettop(L) == 4);
  return 0;
}


/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  lua_checkstack(L,21);
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
  
  /* local M = {} */
  lc_newclosuretable(L,lua_upvalueindex(1));
  enum { lc1 = 1 };
  assert((lua_gettop(L) == (lc1 + lc_nextra)));
  lua_newtable(L);
  lua_rawseti(L,(lc1 + lc_nextra),1);
  assert(lua_gettop(L) - lc_nextra == 1);
  
  /* -- Lua 5.1 and 5.2 compat
   * local load = pcall(load, '') and load or function(ld, source, mode_, env)
   *   local f, err = loadstring(ld, source)
   *   if not f then return f, err end
   *   return setfenv(f, env or _G)
   * end */
  lc_newclosuretable(L,(lc1 + lc_nextra));
  enum { lc2 = 2 };
  assert((lua_gettop(L) == (lc2 + lc_nextra)));
  lua_getfield(L,LUA_ENVIRONINDEX,"pcall");
  lua_getfield(L,LUA_ENVIRONINDEX,"load");
  lua_pushliteral(L,"");
  lua_call(L,2,1);
  if (lua_toboolean(L,-1)) {
    lua_pop(L,1);
    lua_getfield(L,LUA_ENVIRONINDEX,"load");
  }
  if (!(lua_toboolean(L,-1))) {
    lua_pop(L,1);
    lua_pushcfunction(L,lcf6);
  }
  lua_rawseti(L,(lc2 + lc_nextra),2);
  assert(lua_gettop(L) - lc_nextra == 2);
  
  /* -- Count number of chars c in string s.
   * local function countchar(s, c)
   *   local count = 0
   *   local i = 1
   *   while true do
   *     i = string.find(s, c, i)
   *     if i then count = count + 1; i = i + 1 else break end
   *   end
   *   return count
   * end */
  lc_newclosuretable(L,(lc2 + lc_nextra));
  enum { lc7 = 3 };
  assert((lua_gettop(L) == (lc7 + lc_nextra)));
  lua_pushcfunction(L,lcf1_countchar);
  lua_rawseti(L,(lc7 + lc_nextra),3);
  assert(lua_gettop(L) - lc_nextra == 3);
  
  /* -- In error message string, translate line numbers from
   * -- processed file to source file.
   * -- linenums is translation array (processed line number ->
   * -- source line number) or source line number.
   * local function fix_linenums(message, linenums)
   *   message = message:gsub("(%b[]:)(%d+)", function(a,n)
   *     n = tonumber(n)
   *     local source_linenum =
   *       type(linenums) == "table" and (linenums[n] or '?') or
   *       type(linenums) == "number" and linenums + n - 1 or
   *       '?'
   *     return a .. source_linenum
   *   end)
   *   return message
   * end */
  lc_newclosuretable(L,(lc7 + lc_nextra));
  enum { lc10 = 4 };
  assert((lua_gettop(L) == (lc10 + lc_nextra)));
  lua_pushcfunction(L,lcf1_fix_linenums);
  lua_rawseti(L,(lc10 + lc_nextra),4);
  assert(lua_gettop(L) - lc_nextra == 4);
  
  /* -- Expands $(...) syntax.
   * local function parse_dollar_paren(pieces, chunk, name, linenum)
   *   local is = 1
   *   for ibegin, iend in chunk:gmatch("()$%b()()") do
   *     local text = chunk:sub(is, ibegin - 1)
   *     local executed = chunk:sub(ibegin+2, iend-2) -- remove parens
   * 
   *     local name2 = name .. ":" .. executed
   *     linenum = linenum + countchar(text, '\n')
   *     local may_have_comment = executed:find("%-%-")
   *     local nl = may_have_comment and "\n" or ""
   * 
   *     pieces[#pieces+1] = ("_put(%q)"):format(text)
   *     if load("return " .. executed, name2) then -- is expression list
   *       pieces[#pieces+1] = "_put(" .. executed .. nl .. ")"
   *     else -- assume chunk
   *       local status, message = load(executed, name2)
   *       if not status then -- unrecognized
   *         if message then
   *           message = fix_linenums(message, linenum)
   *         end
   *         return status, message
   *       end
   *       pieces[#pieces+1] = " " .. executed .. nl .. " "
   *       linenum = linenum + countchar(executed, '\n')
   *     end
   *     is = iend
   *   end
   *   pieces[#pieces+1] = ("_put(%q)"):format(chunk:sub(is))
   *   return true
   * end */
  lc_newclosuretable(L,(lc10 + lc_nextra));
  enum { lc15 = 5 };
  assert((lua_gettop(L) == (lc15 + lc_nextra)));
  lua_pushvalue(L,(lc15 + lc_nextra));
  lua_pushcclosure(L,lcf1_parse_dollar_paren,1);
  lua_rawseti(L,(lc15 + lc_nextra),6);
  assert(lua_gettop(L) - lc_nextra == 5);
  
  /* -- Expands #... syntax.
   * local function parse_hash_lines(chunk, name, env)
   *   local pieces = {}
   * 
   *   local luas = {} -- for improved error reporting
   *   local linenums = {}
   *   local linenum = 1
   * 
   *   pieces[#pieces+1] = "local _put = ... "
   * 
   *   local is = 1
   *   while true do
   *     local _, ie, lua = chunk:find("^#+([^\n]*\n?)", is)
   *     if not ie then
   *       local iss; iss, ie, lua = chunk:find("\n#+([^\n]*\n?)", is)
   *       local text = chunk:sub(is, iss)
   *       local status, message = parse_dollar_paren(pieces, text, name, linenum)
   *       if not status then return status, message end
   *       if not ie then break end
   *       linenum = linenum + countchar(text, '\n')
   *     end
   * 
   *     luas[#luas+1] = lua
   *     linenums[#linenums+1] = linenum
   *     linenum = linenum + 1
   * 
   *     pieces[#pieces+1] = ' ' .. lua .. ' '
   * 
   *     is = ie + 1
   *   end
   *  
   *   local code = table.concat(pieces, ' ')
   * 
   *   -- Attempt to compile.
   *   local f, message = load(code, name, 't', env)
   *   if not f then
   *     -- Attempt to compile only user-written Lua
   *     -- (for cleaner error message)
   *     local lua = table.concat(luas)
   *     local f2, message2 = load(lua, name, 't', env)
   *     if not f2 then
   *       message = fix_linenums(message2, linenums)
   *     else -- unexpected
   *       message = fix_linenums(message, nil)
   *     end
   *   end
   * 
   *   return f, message
   * end */
  lc_newclosuretable(L,(lc15 + lc_nextra));
  enum { lc27 = 6 };
  assert((lua_gettop(L) == (lc27 + lc_nextra)));
  lua_pushvalue(L,(lc27 + lc_nextra));
  lua_pushcclosure(L,lcf1_parse_hash_lines,1);
  lua_rawseti(L,(lc27 + lc_nextra),7);
  assert(lua_gettop(L) - lc_nextra == 6);
  
  /* -- Abstraction of string output stream.
   * local function string_writer()
   *   local t = {}
   *   local function write(...)
   *     local n = select('#', ...)
   *     if n > 0 then
   *       t[#t+1] = tostring((...))
   *       write(select(2, ...))
   *     end
   *   end
   *   local function close()
   *     return table.concat(t)
   *   end
   *   return {write=write, close=close}
   * end */
  lc_newclosuretable(L,(lc27 + lc_nextra));
  enum { lc43 = 7 };
  assert((lua_gettop(L) == (lc43 + lc_nextra)));
  lua_pushcfunction(L,lcf1_string_writer);
  lua_rawseti(L,(lc43 + lc_nextra),8);
  assert(lua_gettop(L) - lc_nextra == 7);
  
  /* -- Abstraction of file output stream.
   * local function file_writer(fh, is_close)
   *   local function write(...)
   *     local n = select('#', ...)
   *     if n > 0 then
   *       fh:write(tostring((...)))
   *       write(select(2, ...))
   *     end
   *   end
   *   local function close()
   *     if is_close then fh:close() end
   *   end
   *   return {write=write, close=close}
   * end */
  lc_newclosuretable(L,(lc43 + lc_nextra));
  enum { lc54 = 8 };
  assert((lua_gettop(L) == (lc54 + lc_nextra)));
  lua_pushcfunction(L,lcf1_file_writer);
  lua_rawseti(L,(lc54 + lc_nextra),11);
  assert(lua_gettop(L) - lc_nextra == 8);
  
  /* -- Convert output specification to output stream.
   * -- A helper function for C<preprocess>.
   * local function make_output(output)
   *   if type(output) == 'string' then
   *     output = string_writer()
   *   elseif type(output) == 'table' then
   *     assert(#output == 1, 'table size must be 1')
   *     local filename = output[1]
   *     local fh, message = io.open(filename, 'w')
   *     if not fh then return false, message end
   *     output = file_writer(fh, true)
   *   elseif io.type(output) == 'file' then
   *     output = file_writer(output, false)
   *   else
   *     error('unrecognized', 2)
   *   end
   *   return output
   * end */
  lc_newclosuretable(L,(lc54 + lc_nextra));
  enum { lc66 = 9 };
  assert((lua_gettop(L) == (lc66 + lc_nextra)));
  lua_pushvalue(L,(lc66 + lc_nextra));
  lua_pushcclosure(L,lcf1_make_output,1);
  lua_rawseti(L,(lc66 + lc_nextra),15);
  assert(lua_gettop(L) - lc_nextra == 9);
  
  /* -- Convert input specification to input stream.
   * -- A helper function for C<preprocess>.
   * local function make_input(input)
   *   if type(input) == 'string' then
   *     input = {text = input, name = 'source'}
   *   elseif type(input) == 'table' then
   *     assert(#input == 1, 'table size must be 1')
   *     local filename = input[1]
   *     local fh, message = io.open(filename)
   *     if not fh then return false, message end
   *     input = {text = fh:read'*a', name = filename}
   *     fh:close()
   *   elseif io.type(input) == 'file' then
   *     input = {text = input:read'*a', name = nil}
   *   else
   *     error('unrecognized', 2)
   *   end
   *   return input
   * end */
  lc_newclosuretable(L,(lc66 + lc_nextra));
  enum { lc80 = 10 };
  assert((lua_gettop(L) == (lc80 + lc_nextra)));
  lua_pushcfunction(L,lcf1_make_input);
  lua_rawseti(L,(lc80 + lc_nextra),16);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* function M.preprocess(t)
   *   if type(t) == 'string' then t = {input = t} end
   *   local input = t.input or io.stdin
   *   local output = t.output or
   *              (type(input) == 'string' and 'string') or io.stdout
   *   local lookup = t.lookup or _G
   *   local strict = t.strict; if strict == nil then strict = true end
   * 
   *   local err; input, err = make_input(input)
   *   if not input then error(err, 2) end
   *   
   *   local name = input.name or "<source>"
   * 
   *   local mt = {}
   *   if strict then
   *     function mt.__index(t,k)
   *       local v = lookup[k]
   *       if v == nil then
   *         error("Undefined global variable " .. tostring(k), 2)
   *       end
   *       return v
   *     end
   *   else
   *     mt.__index = lookup
   *   end
   *   
   *   local env = {}
   *   setmetatable(env, mt)
   *   
   *   local f, message = parse_hash_lines(input.text, name, env)
   *   if not f then return f, message end
   * 
   *   output = make_output(output)
   * 
   *   local status, message = pcall(f, output.write)
   * 
   *   local result = output.close()
   *   if not result then result = true end
   * 
   *   if not status then
   *     return false, message
   *   else
   *     return result
   *   end
   * end */
  lua_pushvalue(L,(lc80 + lc_nextra));
  lua_pushcclosure(L,lcf1_M_preprocess,1);
  lc_getupvalue(L,(lc80 + lc_nextra),9,1);
  lua_insert(L,-2);
  lua_pushliteral(L,"preprocess");
  lua_insert(L,-2);
  lua_settable(L,-3);
  lua_pop(L,1);
  assert(lua_gettop(L) - lc_nextra == 10);
  
  /* local function command()
   * 	input = io.stdin
   * 	output = io.stdout
   * 
   *   local input, output
   *   local status, message = M.preprocess{input=input, output=output, lookup=_G}
   *   if not status then
   *     io.stderr:write(message .. "\n")
   *     os.exit(1)
   *   end
   * end */
  lua_pushvalue(L,(lc80 + lc_nextra));
  lua_pushcclosure(L,lcf1_command,1);
  assert(lua_gettop(L) - lc_nextra == 11);
  
  /* command() */
  lua_pushvalue(L,(11 + lc_nextra));
  lua_call(L,0,0);
  assert(lua_gettop(L) - lc_nextra == 11);
  return 0;
}


/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}


static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}

static int lc_report (lua_State *L, int status) {
  if (status && !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}

static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}

static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}


typedef struct {
  int c;
  const char ** v;
} lc_args_t;


/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}


static int lc_pmain(lua_State * L) {
  luaL_openlibs(L);

  const lc_args_t * const args = (lc_args_t*)lua_touserdata(L, 1);
  lc_createarg(L, args);

  lua_pushcfunction(L, traceback);

  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;

  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);
  int i;
  for (i=1; i < args->c; i++) {
    lua_pushstring(L, args->v[i]);
  }
  int status2 = lua_pcall(L, args->c-1, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}


int main(int argc, const char ** argv) {
  lc_args_t args = {argc, argv};
  lua_State * L = luaL_newstate();
  if (! L) { fputs("Failed creating Lua state.", stderr); exit(1); }

  int status = lua_cpcall(L, lc_pmain, &args);
  if (status != 0) {
    fputs(lua_tostring(L,-1), stderr);
  }

  lua_close(L);
  return 0;
}


